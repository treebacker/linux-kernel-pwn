## 								CVE-2021-41073

### Vulnerablity 

*io_uring*是在kernel 5.1之后引入的一个异步子系统，陆续支持原Linux的各个系统调用的异步实现。并且正处于快速迭代阶段，增加了很多新的功能特点。

其中一个功能是`IORING_OP_PROVIDER_BUFFERS`，支持App注册一个缓冲区池，用于kernel存储数据。一个典型的场景就是：一个服务器，创建了多个网络连接，在未获取数据包时需要提前分配大量的缓冲区，造成内存开销，但是如果存在一个缓冲区池，在收到数据包后再从池子里取出一个buffer使用，可以减少内存开销。

引入这一特点的[commit](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=ddf0322db79c5984dc1a1db890f946dd19b7d6d9)

注册的`buffer`以group ID分组管理，每一个buffer有一个独立的id，`bid`。每当App提交一个`req`时，指定`flag` 

`IOSQE_BUFFER_SELECT `，提供一个group ID就可以让kernel使用该缓冲池里的一个buffer，在该`req`完成后，使用的缓冲区的`bid`返回在`cqe`结构体中。

### Structure & Function

当提交一个`IORING_OP_PROVIDER_BUFFERS`request注册一组缓冲区时，内核的函数调用链如下

```c
io_provide_buffers_prep (sqe=0xffff8880046f0000, req=0xffff8880046add00) at fs/io_uring.c:3924
#1  io_req_prep (sqe=0xffff8880046f0000, req=0xffff8880046add00) at fs/io_uring.c:5893
#2  io_submit_sqe (sqe=<optimized out>, req=0xffff8880046add00, ctx=0xffff888004673000) at fs/io_uring.c:6530
#3  io_submit_sqes (ctx=ctx@entry=0xffff888004673000, nr=nr@entry=1) at fs/io_uring.c:6694
#4  0xffffffff8124dbbe in __do_sys_io_uring_enter
```

由`io_provide_buffers_prep`，根据`sqe`中提供的用户态的缓冲区信息，以liburing为例

```c
	io_uring_prep_provide_buffers(sqe, bufs1, 0x100, 2, group_id1, 0);
```

初始化缓冲区组结构体`io_provide_buf`

```c
struct io_provide_buf {
	struct file			*file;
	__u64				addr;				// 缓冲区组起始地址
	__s32				len;				// 每一个buf长度	（有符号整数）
	__u32				bgid;				// buf_group id
	__u16				nbufs;				// buf 数量
	__u16				bid;				// buf id (第一个buf id; 如果定义了多个依次递增)
};
```

之后，调用`io_provide_buffers`将前面得到的`buf_group`里的buf构造成一个链表结构，便于管理与查询使用。

这个过程是`io_add_buffers`完成的，为每一个`buf_group`组里的每一个`buffer`分配一个`io_buffer`

```c
struct io_buffer {
	struct list_head list;		
	__u64 addr;
	__s32 len;
	__u16 bid;
};
```

在整个`sqe`处理过程中，每一个`request`都有一个对应的`io_kiocb`结构，存储中间每一个环节的信息。

其中的`union`结构定义了为每一种`request`服务的结构，用于处理`r/w`操作的是`io_rw`

```c
struct io_rw {
	/* NOTE: kiocb has the file as the first member, so don't do it here */
	struct kiocb			kiocb;
	u64				addr;
	u64				len;
};
```

当指定`IOSQE_BUFFER_SELECT`去read/write时，对应的调用链

```c
#1  io_rw_buffer_select (needs_lock=false, len=0xffffc900001b7bc0, req=0xffff8880046add00) at fs/io_uring.c:2877
#2  io_import_iovec (rw=rw@entry=0, req=req@entry=0xffff8880046add00, iovec=iovec@entry=0xffffc900001b7c20, 
    iter=iter@entry=0xffffc900001b7c28, needs_lock=needs_lock@entry=false) at fs/io_uring.c:2974
#3  0xffffffff8124a012 in io_read
```

在函数`io_rw_buffer_select`

```c
static void __user *io_rw_buffer_select(struct io_kiocb *req, size_t *len,
					bool needs_lock)
{
	struct io_buffer *kbuf;
	u16 bgid;

	kbuf = (struct io_buffer *) (unsigned long) req->rw.addr;		[1]
	bgid = req->buf_index;
	kbuf = io_buffer_select(req, len, bgid, kbuf, needs_lock);
	if (IS_ERR(kbuf))
		return kbuf;
	req->rw.addr = (u64) (unsigned long) kbuf;
	req->flags |= REQ_F_BUFFER_SELECTED;
	return u64_to_user_ptr(kbuf->addr);
}
```

这里[1]处的`req->rw.addr`来自`privode_buffers`注册的缓冲区起始地址

```c
(gdb) p req->rw.addr
$14 = 4974176
```

调用`io_buffer_select`在指定的`buf_group`里选择大小满足的一个buffer

`io_buffer_select`将根据`buf_group id`寻找对应的`io_buffers`链表，取出表头`io_buffer`作为待使用的`buffer`，并将其从链表删除。将取出的`buffer`作为`req->rw.addr`即用户态read/write结果存储的地址。

```c
2880		req->rw.addr = (u64) (unsigned long) kbuf;
(gdb) p kbuf
$25 = (struct io_buffer *) 0xffff888003057900
(gdb) p req->rw.addr
$26 = 4974176
```

这里比较奇怪地就是`req->rw.addr`是用户态指定的read/write的操作地址，但是这里却使用了`kbuf.addr`是一个内核态地址。如果在其他地方使用`req->rw.addr`作为read/write对象，并错误地认为这里是一个用户态地址，那就出现了非预期的问题。

问题出现在函数`loop_rw_iter`中，对于`file_operations`结构中没有`read_iter`和`write_iter`函数的，调用该函数完成`loop read/write`。`/proc`下的文件就是这种情况。

```c
/*
 * For files that don't have ->read_iter() and ->write_iter(), handle them
 * by looping over ->read() or ->write() manually.
 */
static ssize_t loop_rw_iter(int rw, struct io_kiocb *req, struct iov_iter *iter)
{
	struct kiocb *kiocb = &req->rw.kiocb;
	struct file *file = req->file;
	ssize_t ret = 0;

	/*
	 * Don't support polled IO through this interface, and we can't
	 * support non-blocking either. For the latter, this just causes
	 * the kiocb to be handled from an async context.
	 */
	if (kiocb->ki_flags & IOCB_HIPRI)
		return -EOPNOTSUPP;
	if (kiocb->ki_flags & IOCB_NOWAIT)
		return -EAGAIN;

	while (iov_iter_count(iter)) {
		struct iovec iovec;
		ssize_t nr;

		if (!iov_iter_is_bvec(iter)) {				[1]
			iovec = iov_iter_iovec(iter);
		} else {
			iovec.iov_base = u64_to_user_ptr(req->rw.addr);
			iovec.iov_len = req->rw.len;
		}

		if (rw == READ) {
			nr = file->f_op->read(file, iovec.iov_base,
					      iovec.iov_len, io_kiocb_ppos(kiocb));
		} else {
			nr = file->f_op->write(file, iovec.iov_base,
					       iovec.iov_len, io_kiocb_ppos(kiocb));
		}

		if (nr < 0) {
			if (!ret)
				ret = nr;
			break;
		}
		ret += nr;
		if (nr != iovec.iov_len)
			break;
		req->rw.len -= nr;				[2]
		req->rw.addr += nr;				[3]
		iov_iter_advance(iter, nr);			[4]
	}

	return ret;
}
```

在**[1]**处，检查`iter`的类型，当该`iter`是`bvec`类型时，将`req->rw.addr`作为read/write的地址；否则通过`iov_iter_iovec`获取一个`struct iovec`；

```c
static inline struct iovec iov_iter_iovec(const struct iov_iter *iter)
{
	return (struct iovec) {
		.iov_base = iter->iov->iov_base + iter->iov_offset,
		.iov_len = min(iter->count,
			       iter->iov->iov_len - iter->iov_offset),
	};
}
```

但是在每一轮iter之后，更新当前read/write尾、下一次read/write头时，没有检查`iter`的类型，而是在[2]\[3]

[4]处，既将`req->rw.addr`作为用户态地址向后增长`nr`，又通过`iov_iter_advance`更新了iter。

在`io`操作完成后，调用`io_iopoll_complete`完成清理工作，如果设置了`REQ_F_BUFFER_SELECTED`，就调用`io_put_rw_kbuf`

```c
		if (req->flags & REQ_F_BUFFER_SELECTED)
			cflags = io_put_rw_kbuf(req);
```

```c
static inline unsigned int io_put_rw_kbuf(struct io_kiocb *req)
{
	struct io_buffer *kbuf;

	kbuf = (struct io_buffer *) (unsigned long) req->rw.addr;		[5]
	return io_put_kbuf(req, kbuf);
}
```

将`req->rw.addr`作为`io_buffer`指针，调用`io_put_kbuf`释放

```c
static unsigned int io_put_kbuf(struct io_kiocb *req, struct io_buffer *kbuf)
{
	unsigned int cflags;

	cflags = kbuf->bid << IORING_CQE_BUFFER_SHIFT;
	cflags |= IORING_CQE_F_BUFFER;
	req->flags &= ~REQ_F_BUFFER_SELECTED;
	kfree(kbuf);								[6]
	return cflags;
}
```

上述代码的`[3] -> [5] -> [6]`就形成了一个类型混淆造成错误地`kfree`，使得最终的效果是`kfree(kbuf + user_read_write_counts)`。

```assembly
(gdb) p req->rw.addr
$37 = 18446612682121849056
(gdb) c
Continuing.

Thread 1 hit Breakpoint 10, io_put_kbuf (kbuf=0xffff88800316a900, req=0xffff8880046add00) at fs/io_uring.c:2203
2203		kfree(kbuf);
(gdb) p kbuf
$38 = (struct io_buffer *) 0xffff88800316a90
(gdb) p 0xffff88800316a900-18446612682121849056
$41 = 32

```

由于`struct io_buffer`大小为32，因此该漏洞允许我们在`kmalloc-32-cache`上free一个距原`chunk` 可控 `offset`的堆

![](exploit/kmalloc32.png)







### Exploitation

基于上面的分析，我们其实达到了kfree一个kmalloc的堆地址，换言之，有了一个触发`UAF`的能力，接下来就是如何利用`UAF`达到提权的目的。

#### 利用步骤

* 将进程的所有线程和`io`线程绑定到相同的cpu上，以便它们使用相同的`kmalloc-32-cache slab`
* 堆喷`io_buffer`占位`kmalloc-32-slab`，便于构造`UAF`
* 利用`UAF`泄漏target object里包含的内核地址
* 利用`UAF`修改target object里的函数指针，劫持kernel执行流，达到提权的目的



##### Kernel内存分布与观察





##### Thread Affinity

每一个线程affinity决定了它将在哪些`cpu`上运行，在多进程系统中，这一设计可以在一定程度提升效率。一个典型的场景就是使某些进程/线程独享某一cpu，保证其运行的效率。

而对于`slub`等内存管理器，它们的`cache`则是`per - cpu`的，也就是在相同cpu上执行的代码，会共享使用`cache`的堆块。

因此，在堆相关的漏洞利用中，进程出现使用**sched_setaffinity**将所选线程绑定到指定的cpu，但是它只允许修改userspace的thread affinity，无法满足这里的场景。

凑巧地是`io_uring`出于性能和资源隔离的考虑，在[fe76421d1da1dcdb3a2cd8428ac40106bff28bc0](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=fe76421d1da1dcdb3a2cd8428ac40106bff28bc0)支持了用户可修改配置`io_work`线程affinity，这就使得`UAF`是可行的。



##### Kernel Universal Heap Spray

一些常见的堆喷利用手法，如`sendmsg/msgsnd`，堆块大小是固定的48bytes（不可控的），并且有不可控的`header`。

而一个通用的堆喷应满足下面的三个条件：

* 堆块object大小是用户态可控的，任意大小（例如kmalloc-8）
* 堆块object内容是用户态可控的，堆块不存在用户不可控的`header`
* 堆块的生命周期可控（进程生命周期内都存在或者用户态触发释放）

一种实现的思路就是将`kmalloc-kfree`（1、2）执行路径和`userfaultfd`（3）结合起来。

在`kmalloc`和`kfree`之间，触发page fault，将执行用户态指定的代码，此时该线程挂起（sleep），间接地满足条件3。

`setxattr`里包含了一个可利用的`kmalloc-kfree`路径

```c
static long
setxattr(struct dentry *d, const char __user *name, const void __user *value,
         size_t size, int flags)
{
        int error;
        void *kvalue = NULL;
        void *vvalue = NULL;    /* If non-NULL, we used vmalloc() */
        char kname[XATTR_NAME_MAX + 1];

        if (flags & ~(XATTR_CREATE|XATTR_REPLACE))
                return -EINVAL;

        error = strncpy_from_user(kname, name, sizeof(kname));
        if (error == 0 || error == sizeof(kname))
                error = -ERANGE;
        if (error < 0)
                return error;

        if (size) {
                if (size > XATTR_SIZE_MAX)
                        return -E2BIG;
[5]             kvalue = kmalloc(size, GFP_KERNEL | __GFP_NOWARN);
                if (!kvalue) {
                        vvalue = vmalloc(size);
                        if (!vvalue)
                                return -ENOMEM;
                        kvalue = vvalue;
                }
[6]             if (copy_from_user(kvalue, value, size)) {
                        error = -EFAULT;
                        goto out;
                }
                if ((strcmp(kname, XATTR_NAME_POSIX_ACL_ACCESS) == 0) ||
                    (strcmp(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == 0))
                        posix_acl_fix_xattr_from_user(kvalue, size);
        }

        error = vfs_setxattr(d, kname, kvalue, size, flags);
out:
        if (vvalue)
                vfree(vvalue);
        else
[7]             kfree(kvalue);
        return error;
}
```

[5]处分配了一个用户态可控size的堆块，[6]处向该堆块写入了可控的内容，满足了前两个条件；但是在[7]处将该堆块给`kfree`了；结合`userfaultfd`，当`copy_from_user`触发了page fault时，将内核代码中断交由用户态控制。

利用方法：**分配两个连续的page，value[:n-8] 在page_1中，value[:-8]在page_2中；内核将成功将value[:n-8]写入kvalue, 而在访问page_2的value[:-8]时，触发page fault，利用userfaultfd，可以使kvalue堆一直存在，便于后续利用**

![](exploit\fuse.png)

**userfaultfd**在高版本linux中默认开启`vm.unprivileged_userfaultfd`不允许非特权用户使用。

**FUSE**提供了另一个可用的方法，`FUSE`是一个用户态的文件系统框架，最大的特点就是允许非特权用户挂载文件系统，当使用`mmap`创建两个连续的page，第二个page是FUSE的fd时，`copy_from_user`访问该page时，由于文件系统的`read/write`函数由非特权用户控制，就可以block kernel，达到`userfaultfd`相同的效果

##### Kernel Universal Leak

上述通过`setxattr`和`userfaultfd/fuse`构造一个通用的heap Spray，事实上，再配合`getxattr`和`UAF`漏洞可以构造一个通用的内核地址泄漏路径

* `setxattr`在`copy_from_user` block
* 利用漏洞free掉`setxattr`中分配的`kvalue`堆
* 再分配一个包含内核地址信息的对象占位刚释放的`kvalue`堆
* block结束，继续`setxattr`，将`kvalue`内容（已经被新分配的对象修改）写入到文件扩展属性中
* `getxaatr`获取泄漏的内核地址信息









### Refer

[iou-ring-exploiting-the-linux-kernel](https://www.graplsecurity.com/post/iou-ring-exploiting-the-linux-kernel#toc-2)

[events-kmem-trace](https://www.kernel.org/doc/html/latest/trace/events-kmem.html)

[kernel_dynamic_memory_analysis](https://elinux.org/Kernel_dynamic_memory_analysis)

[man-sched_setaffinity](https://man7.org/linux/man-pages/man2/sched_setaffinity.2.html)

[]()