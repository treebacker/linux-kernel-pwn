### 				CVE-2017-5123 Waitpid漏洞

#### 漏洞成因

在Linux4.13中修改了`waitpid`系统调用，将`put_user`修改为了`unsafe_put_user`，并且没有检查指针的合法性，导致了漏洞的产生，并且一直影响到`linux.4.14-rcxx`。

##### 漏洞源码

漏洞代码：https://elixir.bootlin.com/linux/v4.14-rc1/source/kernel/exit.c

`waitpid`

```c
SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,
		infop, int, options, struct rusage __user *, ru)
{
	struct rusage r;
	struct waitid_info info = {.status = 0};
	long err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);
	int signo = 0;
	if (err > 0) {
		signo = SIGCHLD;
		err = 0;
	}

	if (!err) {
		if (ru && copy_to_user(ru, &r, sizeof(struct rusage)))
			return -EFAULT;
	}
	if (!infop)
		return err;

	user_access_begin();
	unsafe_put_user(signo, &infop->si_signo, Efault);
	unsafe_put_user(0, &infop->si_errno, Efault);
	unsafe_put_user(info.cause, &infop->si_code, Efault);
	unsafe_put_user(info.pid, &infop->si_pid, Efault);
	unsafe_put_user(info.uid, &infop->si_uid, Efault);
	unsafe_put_user(info.status, &infop->si_status, Efault);
	user_access_end();
	return err;
Efault:
	user_access_end();
	return -EFAULT;
}
```

对于`unsafe_put_user`函数：

```c
/*
 * The "unsafe" user accesses aren't really "unsafe", but the naming
 * is a big fat warning: you have to not only do the access_ok()
 * checking before using them, but you have to surround them with the
 * user_access_begin/end() pair.
 */
#define user_access_begin()	__uaccess_begin()
#define user_access_end()	__uaccess_end()

#define unsafe_put_user(x, ptr, err_label)					\
do {										\
	int __pu_err;								\
	__typeof__(*(ptr)) __pu_val = (x);					\
	__put_user_size(__pu_val, (ptr), sizeof(*(ptr)), __pu_err, -EFAULT);	\
	if (unlikely(__pu_err)) goto err_label;					\
} while (0)
```

也就是需要在使用`unsafe_put_user`前使用`access_ok`检查合法性，以及`user_access_begin`和`user_access_end`。而这里没有`access_ok`。

##### SMEP & SMAP

Linux内核出于安全考虑，严格隔离userspace和kernelspace：SMEP竞争内核执行用户空间代码，SMAP禁止内核访问用户空间代码。因此，当通过系统调用进入内核空间时，如果需要访问一个地址，内核将通过`access_ok`检查该地址是否位于用户进程的地址空间中（是否合法）

```c
/**
 * access_ok: - Checks if a user space pointer is valid
 * @type: Type of access: %VERIFY_READ or %VERIFY_WRITE.  Note that
 *        %VERIFY_WRITE is a superset of %VERIFY_READ - if it is safe
 *        to write to a block, it is always safe to read from it.
 * @addr: User space pointer to start of block to check
 * @size: Size of block to check
 *
 * Context: User context only. This function may sleep if pagefaults are
 *          enabled.
 *
 * Checks if a pointer to a block of memory in user space is valid.
 *
 * Returns true (nonzero) if the memory block may be valid, false (zero)
 * if it is definitely invalid.
 *
 * Note that, depending on architecture, this function probably just
 * checks that the pointer is in the user space range - after calling
 * this function, memory access functions may still return -EFAULT.
 */
#define access_ok(type, addr, size)					\
({									\
	WARN_ON_IN_IRQ();						\
	likely(!__range_not_ok(addr, size, user_addr_max()));		\
})
```

即检查地址`addr`到`addr+size`是否在`user_addr_max`范围内。

当地址合法之后，就需要`user_access_begin`禁用`SMAP`允许内核访问用户空间：

```c
#define __uaccess_begin() stac()
#define __uaccess_end()   clac()
....
#define user_access_begin()	__uaccess_begin()
#define user_access_end()	__uaccess_end()
....

static __always_inline void clac(void)
{
	/* Note: a barrier is implicit in alternative() */
	alternative("", __stringify(__ASM_CLAC), X86_FEATURE_SMAP);
}

static __always_inline void stac(void)
{
	/* Note: a barrier is implicit in alternative() */
	alternative("", __stringify(__ASM_STAC), X86_FEATURE_SMAP);
}

//__ASM_CLAC 和 __ASM_STAC
/* "Raw" instruction opcodes */
#define __ASM_CLAC	.byte 0x0f,0x01,0xca
#define __ASM_STAC	.byte 0x0f,0x01,0xcb
```

可以看到`__uaccess_begin`通过`stac`指令设置**EFLAGS.AC**禁用SMAP，`__uaccess_end`通过`clac`指令清除**EFLAGS.AC**启用SMAP，这样就完成了一段区间的内核访问用户地址空间的需求。

而问题就在于，`waitpid`函数的参数`infop`来自用户空间，却忘了`access_ok`检查它是否真的是在用户进程地址空间，导致后续的`unsafe_put_user(content, ptr, Efault)`将`content`写入一个任意地址（包括内核地址空间）`ptr`。

在`waitpid`代码中，**unsafe_put_user(0, &infop->si_errno, Efault);**可以完成向任意地址写入一个0。

特别地，如果向进程的`cred->uid`写入0的话，就完成了一次本地提权。

#### 漏洞利用

##### 提权方式

通过上述分析，提权的基本思路就是利用`waitpid`的这个漏洞向`cred->uid`写入0。重点是如何得到内核地址空间的进程的`cred`地址。

通过下面的一个内核模块，每次fork的子进程open一次该模块，可以观察内核里进程的`cred`地址分布

```
#include <linux/module.h>
#include <linux/init.h>
#include <linux/kernel.h>
#include <linux/sched.h>
#include <linux/fs.h>        // for basic filesystem
#include <linux/proc_fs.h>    // for the proc filesystem
#include <linux/seq_file.h>    // for sequence files
 
static struct proc_dir_entry* jif_file;
 
static int
jif_show(struct seq_file *m, void *v)
{
    return 0;
}
 
static int
jif_open(struct inode *inode, struct file *file)
{
     printk("EUID: %p\n", &current->cred->euid);
     return single_open(file, jif_show, NULL);
}
 
static const struct file_operations jif_fops = {
    .owner    = THIS_MODULE,
    .open    = jif_open,
    .read    = seq_read,
    .llseek    = seq_lseek,
    .release    = single_release,
};
 
static int __init
jif_init(void)
{
    jif_file = proc_create("jif", 0, NULL, &jif_fops);
 
    if (!jif_file) {
        return -ENOMEM;
    }
 
    return 0;
}
 
static void __exit
jif_exit(void)
{
    remove_proc_entry("jif", NULL);
}
 
module_init(jif_init);
module_exit(jif_exit);
 
MODULE_LICENSE("GPL");
```

##### 堆喷

一个常见的方式，通过`fork`大量的子进程，得到大量的`cred`结构。

通过`clone`函数fork大量子进程，相较于fork，clone允许直接指定子进程执行的代码：

```
```

##### have_canfork_callback空指针引用

除了直接修改cred结构体的uid，也可以修改内核内的可写的函数指针为NULL，并且能够触发执行该函数，就可以造成空指针引用，在能够mmap NULL的前提下，就可以将Shellcode存在NULL地址处，执行shellcode提权。

##### 不足

该漏洞的利用需要配合内核地址泄漏，否则成功率太低。





#### 参考

[CVE-2017-5123-Linux-kernel-v4.13](https://de4dcr0w.github.io/CVE-2017-5123-Linux-kernel-v4.13-waitid()-%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0.html)

[Explot-2017-5123](https://reverse.put.as/2017/11/07/exploiting-cve-2017-5123/)

