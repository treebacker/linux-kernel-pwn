#### 漏洞摘要

CVE-2014-0193

#### 源码分析

以https://elixir.bootlin.com/linux/v3.14.3/source/drivers/tty/n_tty.c代码为分析背景。

* 条件竞争漏洞

  在`drivers/tty/n_tty.c`下函数`n_tty_write`中

  补丁前v3.14.3

  ```c
  while (nr > 0) {
  				c = tty->ops->write(tty, b, nr);
  				if (c < 0) {
  					retval = c;
  					goto break_out;
  				}
  				if (!c)
  					break;
  				b += c;
  				nr -= c;
  			}
  ```

  补丁后v3.14.4

  ```c
  	while (nr > 0) {
  				mutex_lock(&ldata->output_lock);
  				c = tty->ops->write(tty, b, nr);
  				mutex_unlock(&ldata->output_lock);
  				if (c < 0) {
  					retval = c;
  					goto break_out;
  				}
  				if (!c)
  					break;
  				b += c;
  				nr -= c;
  			}
  ```

  可以看到，漏洞在于`n_tty_write`函数在向`tty`的缓冲区写数据时没有加锁同步，导致存在潜在的竞争风险。

  其中`tty_struct`结构

  ```c
  struct tty_struct {
  	int	magic;
  	struct kref kref;
  	struct device *dev;
  	struct tty_driver *driver;
  	const struct tty_operations *ops;
  	int index;
  	...
  }
  ```

  `tty_operations`结构定义了`tty_struct`的操作函数指针，类似`file_operation`。

  ```c
  struct tty_operations {
  	struct tty_struct * (*lookup)(struct tty_driver *driver,
  			struct inode *inode, int idx);
  	int  (*install)(struct tty_driver *driver, struct tty_struct *tty);
  	void (*remove)(struct tty_driver *driver, struct tty_struct *tty);
  	int  (*open)(struct tty_struct * tty, struct file * filp);
  	void (*close)(struct tty_struct * tty, struct file * filp);
  	void (*shutdown)(struct tty_struct *tty);
  	void (*cleanup)(struct tty_struct *tty);
  	int  (*write)(struct tty_struct * tty,
  		      const unsigned char *buf, int count);
  	...
  }
  ```

  因此，`tty_strcut`经常作为缓冲区溢出或者`UAF`等漏洞攻击点，通过修改`tty_operations`的函数指针，就可以触发执行payload，完成提权。

* 类型转换漏洞

  用户态向`pty`缓冲区写入数据的函数执行流程大致如下：

  ```c
  write(pty_fd, ....) [userspace] -> sys_write(kernel space) -> tty_write -> pty_write
      ->tty_insert_flip_string -> tty_insert_flip_string_fixed_flag
  ```

  `drivers/tty/tty_buffer.c`中`tty_insert_flip_string_fixed_flag`函数

  ```c
  /**
   *	tty_insert_flip_string_fixed_flag - Add characters to the tty buffer
   *	@port: tty port
   *	@chars: characters
   *	@flag: flag value for each character
   *	@size: size
   *
   *	Queue a series of bytes to the tty buffering. All the characters
   *	passed are marked with the supplied flag. Returns the number added.
   */
  
  int tty_insert_flip_string_fixed_flag(struct tty_port *port,
  		const unsigned char *chars, char flag, size_t size)
  {
  	int copied = 0;
  	do {
  		int goal = min_t(size_t, size - copied, TTY_BUFFER_PAGE);
  		int flags = (flag == TTY_NORMAL) ? TTYB_NORMAL : 0;
  		int space = __tty_buffer_request_room(port, goal, flags);
  		struct tty_buffer *tb = port->buf.tail;
  		if (unlikely(space == 0))
  			break;
  		memcpy(char_buf_ptr(tb, tb->used), chars, space);
  		if (~tb->flags & TTYB_NORMAL)
  			memset(flag_buf_ptr(tb, tb->used), flag, space);
  		tb->used += space;
  		copied += space;
  		chars += space;
  		/* There is a small chance that we need to split the data over
  		   several buffers. If this is the case we must loop */
  	} while (unlikely(size > copied));
  	return copied;
  }
  ```

  该函数主要在循环中（避免分配跨页内存）完成的工作：

  * 每次copy  min (size - copied, TTY_BUFFER_PAGE)的数据
  * `tb->used`标记tty_buffer已经使用的缓冲区大小
  * 其中，每次copy数据前通过`__tty_buffer_request_room`函数判断tty_buffer缓冲区是否充足，如果不足需要重新分配。

  `__tty_buffer_request_room`函数

  ```c
  static int __tty_buffer_request_room(struct tty_port *port, size_t size,
  				     int flags)
  {
  	struct tty_bufhead *buf = &port->buf;
  	struct tty_buffer *b, *n;
  	int left, change;
  	
  	b = buf->tail;
  	if (b->flags & TTYB_NORMAL)
  		left = 2 * b->size - b->used;
  	else
  		left = b->size - b->used;				// 获取tty_buffer剩余缓冲区size
  
  	change = (b->flags & TTYB_NORMAL) && (~flags & TTYB_NORMAL);
  	if (change || left < size) {				// 缓冲区不足
  		/* This is the slow path - looking for new buffers to use */
  		if ((n = tty_buffer_alloc(port, size)) != NULL) {
  			n->flags = flags;					// 分配新的缓冲区
  			buf->tail = n;
  			b->commit = b->used;
  			smp_mb();
  			b->next = n;
  		} else if (change)
  			size = 0;
  		else
  			size = left;
  	}
  	return size;
  }
  
  ```

  通过`tty_buffer->size - tty_buffer->used`获取`tty_buffer`剩余缓冲区大小`left`，再通过`left < size`比较是否缓冲区足够，来决定是否分配新的缓冲区。

  但是这里的问题是，`left`类型是`int`，而`size`类型是`size_t`即`unsigned long`；因此在比较时`left`将被转为`unsigned long`，当`left`为负数时，使得该判断失败，认为缓冲区足够，并返回一个很大的`size = left`，进而导致`tty_insert_flip_string_fixed_flag`中的`memcpy`溢出。

  但是事实上，正常情况下上面描述的情况不会出现（这也是为什么这一部分代码并没有fixed），因为`left =  b->size - b->used`，而`b -> used`的增长是不允许超过`b -> size`的。

  

  但是由于对`tty`的写没有同步的原因，导致可能存在下面的场景：

  * 线程A对 某 tty 缓冲区写入  size_a的数据，在通过`__tty_buffer_request_room`验证后，memcpy写入tty缓冲区；但还没有更新`tty_buffer -> used`；此时，线程B抢占对同一个tty 缓冲区写入 size_b 数据，并通过`__tty_buffer_request_room`验证，memcpy写入数据。

    这两次对该tty缓冲区的写入实际大小为`size_a + size_b`，而上述两次验证只满足`left > size_a`和`left > size_b`，如果`left < size_a + size_b`，就说明已经溢出了。

  * 同时，如果再一次向该tty缓冲区写入数据，此时`left`为负数，导致获得一个很大的`size`，memcpy导致任意长度的溢出。

#### 漏洞利用

* 攻击原理

  利用条件竞争和类型转换造成`tty_buffer`堆缓冲区的溢出；

  利用堆喷在堆上构造多个`tty_struct`结构；

  当`tty_buffer`成功溢出覆盖`tty_struct`结构，重写`tty_oepration`下的函数指针时，就可以完成提权。

* Exploit过程

  * 条件竞争 + 类型混淆
  * 堆喷
  * 溢出